/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { Signal } from '@lumino/signaling';
/**
 * Connector class that handles execute request to a kernel
 */
export class KernelConnector {
    _kernel;
    _kernelRestarted = new Signal(this);
    constructor(options) {
        this._kernel = options.kernel;
        this._kernel.connection?.statusChanged.connect((_, newStatus) => {
            switch (newStatus) {
                case 'restarting':
                case 'autorestarting':
                    this._kernelRestarted.emit(this._kernel.ready);
                    break;
                default:
                    break;
            }
        });
    }
    get kernelRestarted() {
        return this._kernelRestarted;
    }
    get kernelLanguage() {
        if (!this._kernel) {
            return Promise.resolve('');
        }
        return this._kernel.connection.info.then(infoReply => {
            return infoReply.language_info.name;
        });
    }
    get kernelName() {
        return this._kernel.connection.name;
    }
    /**
     *  A Promise that is fulfilled when the session associated w/ the connector is ready.
     */
    get ready() {
        return this._kernel.ready;
    }
    /**
     *  A signal emitted for iopub messages of the kernel associated with the kernel.
     */
    get iopubMessage() {
        return this._kernel.connection.iopubMessage;
    }
    /**
     * Executes the given request on the kernel associated with the connector.
     * @param content: IExecuteRequestMsg to forward to the kernel.
     * @param ioCallback: Callable to forward IOPub messages of the kernel to.
     * @returns Promise<KernelMessage.IExecuteReplyMsg>
     */
    fetch(content, ioCallback) {
        const kernel = this._kernel.connection;
        if (!kernel) {
            return Promise.reject(new Error('Require kernel to perform variable inspection!'));
        }
        const future = kernel.requestExecute(content);
        future.onIOPub = (msg) => {
            ioCallback(msg);
        };
        return future.done;
    }
    execute(content) {
        if (!this._kernel.connection) {
            throw new Error('No session available.');
        }
        return this._kernel.connection.requestExecute(content);
    }
}
//# sourceMappingURL=kernelconnector.js.map