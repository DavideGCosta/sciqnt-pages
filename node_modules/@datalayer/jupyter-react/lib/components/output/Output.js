import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { useState, useMemo, useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { Box } from '@primer/react';
import { UUID } from '@lumino/coreutils';
import { useJupyter } from '../../jupyter/JupyterContext';
import { KernelActionMenu, KernelProgressBar } from './../kernel';
import Lumino from '../lumino/Lumino';
import CodeMirrorEditor from '../codemirror/CodeMirrorEditor';
import { selectExecute, outputActions, outputReducer } from './OutputRedux';
import OutputAdapter from './OutputAdapter';
import OutputRenderer from './OutputRenderer';
import './Output.css';
export const Output = (props) => {
    const { injectableStore, defaultKernel: kernel } = useJupyter();
    const { adapter: propsAdapter, autoRun, clearTrigger, code, codePre, disableRun, executeTrigger, insertText, lumino, model, receipt, showControl, showEditor, sourceId, toolbarPosition, } = props;
    const dispatch = useDispatch();
    const [id, setId] = useState(sourceId);
    const [kernelStatus, setKernelStatus] = useState('unknown');
    const [outputs, setOutputs] = useState(props.outputs);
    const [adapter, setAdapter] = useState();
    useMemo(() => {
        injectableStore.inject('output', outputReducer);
    }, [sourceId]);
    useEffect(() => {
        if (!id) {
            setId(UUID.uuid4());
        }
    }, []);
    useEffect(() => {
        if (id && kernel) {
            const adapter = propsAdapter ?? new OutputAdapter(kernel, outputs ?? [], model);
            if (receipt) {
                adapter.outputArea.model.changed.connect((sender, change) => {
                    if (change.type === 'add') {
                        change.newValues.map(val => {
                            if (val && val.data) {
                                const out = val.data['text/html']; // val.data['application/vnd.jupyter.stdout'];
                                if (out) {
                                    if (out.indexOf(receipt) > -1) {
                                        dispatch(outputActions.grade({
                                            sourceId,
                                            success: true,
                                        }));
                                    }
                                }
                            }
                        });
                    }
                });
            }
            setAdapter(adapter);
            adapter.outputArea.model.changed.connect((outputModel, args) => {
                setOutputs(outputModel.toJSON());
            });
        }
    }, [id, kernel]);
    useEffect(() => {
        if (adapter) {
            if (!adapter.kernel) {
                adapter.kernel = kernel;
            }
            if (autoRun) {
                adapter.execute(code);
            }
        }
    }, [adapter]);
    useEffect(() => {
        if (kernel) {
            kernel.ready.then(() => {
                setKernelStatus(kernel.connection.status);
                kernel.connection.statusChanged.connect((kernelConnection, status) => {
                    setKernelStatus(status);
                });
            });
            return () => {
                //        kernel.connection.then(k => k.shutdown().then(() => console.log(`Kernel ${k.id} is terminated.`)));
            };
        }
    }, [kernel]);
    const executeRequest = selectExecute(sourceId);
    useEffect(() => {
        if (adapter && executeRequest && executeRequest.sourceId === id) {
            adapter.execute(executeRequest.source);
        }
    }, [executeRequest, adapter]);
    useEffect(() => {
        if (adapter && executeTrigger > 0) {
            adapter.execute(code);
        }
    }, [executeTrigger]);
    useEffect(() => {
        if (adapter && clearTrigger > 0) {
            adapter.clear();
        }
    }, [clearTrigger, adapter]);
    return (_jsxs(_Fragment, { children: [showEditor && adapter && id && (_jsx(Box, { sx: {
                    '& .cm-editor': {
                        borderRadius: '5px',
                    },
                }, children: _jsx(CodeMirrorEditor, { autoRun: autoRun, code: code, codePre: codePre, disableRun: disableRun, insertText: insertText, kernel: kernel, outputAdapter: adapter, sourceId: id, toolbarPosition: toolbarPosition }) })), adapter && (_jsxs(Box, { display: "flex", children: [_jsx(Box, { flexGrow: 1, children: kernelStatus !== 'idle' && _jsx(KernelProgressBar, {}) }), showControl && (_jsx(Box, { style: { marginTop: '-13px' }, children: _jsx(KernelActionMenu, { kernel: kernel, outputAdapter: adapter }) }))] })), outputs && (_jsx(Box, { sx: {
                    '& .jp-OutputArea': {
                        fontSize: '10px',
                    },
                    '& .jp-OutputPrompt': {
                    //              display: 'none',
                    },
                    '& .jp-OutputArea-prompt': {
                        display: 'none',
                        //              width: '0px',
                    },
                    '& pre': {
                        fontSize: '12px',
                        wordBreak: 'break-all',
                        wordWrap: 'break-word',
                        whiteSpace: 'pre-wrap',
                    },
                }, children: lumino
                    ? adapter && _jsx(Lumino, { children: adapter.outputArea })
                    : outputs && (_jsx(_Fragment, { children: outputs.map((output) => {
                            return _jsx(OutputRenderer, { output: output });
                        }) })) }))] }));
};
Output.defaultProps = {
    clearTrigger: 0,
    disableRun: false,
    executeTrigger: 0,
    showControl: true,
    lumino: true,
    outputs: [
        {
            output_type: 'execute_result',
            data: {
                'text/html': [
                    '<p>Type code in the cell and Shift+Enter to execute.</p>',
                ],
            },
            execution_count: 0,
            metadata: {},
        },
    ],
    toolbarPosition: 'up',
};
export default Output;
//# sourceMappingURL=Output.js.map