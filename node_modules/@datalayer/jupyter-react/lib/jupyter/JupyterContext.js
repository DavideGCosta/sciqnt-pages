import { Fragment as _Fragment, jsx as _jsx } from "react/jsx-runtime";
/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { ServerConnection, ServiceManager, } from '@jupyterlab/services';
import { createContext, useContext, useEffect, useState } from 'react';
import { Provider as ReduxProvider } from 'react-redux';
import defaultInjectableStore from '../state/redux/Store';
import { createLiteServer } from './../jupyter/lite/LiteServer';
import { getJupyterServerHttpUrl, getJupyterToken } from './JupyterConfig';
import { requestAPI } from './JupyterHandlers';
import Kernel from './kernel/Kernel';
/**
 * The instance for the Jupyter context.
 */
export const JupyterContext = createContext(undefined);
export const useJupyter = () => {
    const context = useContext(JupyterContext);
    if (!context) {
        throw new Error('useContext must be inside a provider with a value.');
    }
    return context;
};
/**
 * The type for the Jupyter context consumer.
 */
export const JupyterContextConsumer = JupyterContext.Consumer;
/**
 * The type for the Jupyter context provider.
 */
const JupyterProvider = JupyterContext.Provider;
/**
 * Utility method to ensure the Jupyter context is authenticated
 * with the Jupyter server.
 */
export const ensureJupyterAuth = async (serverSettings) => {
    try {
        await requestAPI(serverSettings, 'api', '');
        return true;
    }
    catch (reason) {
        console.log('The Jupyter Server API has failed with reason', reason);
        return false;
    }
};
export const createServerSettings = (baseUrl, wsUrl) => {
    return ServerConnection.makeSettings({
        baseUrl,
        wsUrl,
        token: getJupyterToken(),
        appendToken: true,
        init: {
            mode: 'cors',
            credentials: 'include',
            cache: 'no-store',
        },
    });
};
/**
 * The Jupyter context provider.
 */
export const JupyterContextProvider = props => {
    const { children, collaborative = false, defaultKernelName = 'python', initCode = '', injectableStore = defaultInjectableStore, lite = false, startDefaultKernel = true, useRunningKernelId, useRunningKernelIndex = -1, skeleton = _jsx(_Fragment, {}), variant = 'default', serverUrls, } = props;
    const { baseUrl, wsUrl } = serverUrls ?? {};
    const [_, setVariant] = useState(variant);
    const [serviceManager, setServiceManager] = useState();
    const [kernel, setKernel] = useState();
    const [kernelIsLoading, setIsLoading] = useState(startDefaultKernel || useRunningKernelIndex > -1);
    // Create a service manager
    useEffect(() => {
        if (lite) {
            createLiteServer().then(async (liteServer) => {
                // Load the browser kernel
                const mod = typeof lite === 'boolean'
                    ? await import('@jupyterlite/pyodide-kernel-extension')
                    : await lite;
                // Load the module manually to get the list of plugin IDs
                let data = mod.default;
                // Handle commonjs exports.
                if (!Object.prototype.hasOwnProperty.call(mod, '__esModule')) {
                    data = mod;
                }
                if (!Array.isArray(data)) {
                    data = [data];
                }
                const pluginIDs = data.map(item => {
                    try {
                        liteServer.registerPlugin(item);
                        return item.id;
                    }
                    catch (error) {
                        console.error(error);
                        return null;
                    }
                });
                // Activate the loaded plugins
                await Promise.all(pluginIDs.filter(id => id).map(id => liteServer.activatePlugin(id)));
                setServiceManager(liteServer.serviceManager);
            });
        }
        else {
            const serverSettings = createServerSettings(baseUrl ?? '', wsUrl ?? '');
            ensureJupyterAuth(serverSettings).then(isAuth => {
                if (!isAuth) {
                    const loginUrl = getJupyterServerHttpUrl() + '/login?next=' + window.location;
                    console.warn('Redirecting to Jupyter Server login URL', loginUrl);
                    window.location.replace(loginUrl);
                }
                if (useRunningKernelId && useRunningKernelIndex > -1) {
                    throw new Error('You can not ask for useRunningKernelId and useRunningKernelIndex at the same time.');
                }
                if (startDefaultKernel &&
                    (useRunningKernelId || useRunningKernelIndex > -1)) {
                    throw new Error('You can not ask for startDefaultKernel and (useRunningKernelId or useRunningKernelIndex) at the same time.');
                }
                const serviceManager = new ServiceManager({ serverSettings });
                setServiceManager(serviceManager);
            });
        }
        setVariant(variant);
    }, [baseUrl, wsUrl, lite, variant]);
    // Create a kernel
    useEffect(() => {
        serviceManager?.kernels.ready.then(async () => {
            const kernelManager = serviceManager.kernels;
            console.log('Kernel Manager is Ready', kernelManager);
            if (useRunningKernelIndex > -1) {
                const running = kernelManager.running();
                let kernel = running.next();
                let i = 0;
                while (!kernel.done) {
                    if (i === useRunningKernelIndex) {
                        const wrappedKernel = new Kernel({
                            kernelManager,
                            kernelName: defaultKernelName,
                            kernelSpecName: defaultKernelName,
                            kernelModel: kernel.value,
                            kernelType: 'notebook',
                            kernelspecsManager: serviceManager.kernelspecs,
                            sessionManager: serviceManager.sessions,
                        });
                        if (initCode) {
                            try {
                                await wrappedKernel.execute(initCode)?.done;
                            }
                            catch (error) {
                                console.error('Failed to execute the initial code', error);
                            }
                        }
                        setKernel(wrappedKernel);
                        setIsLoading(false);
                        break;
                    }
                    kernel = running.next();
                    i++;
                }
                setIsLoading(false);
            }
            else if (startDefaultKernel) {
                console.log('Starting Kernel Name:', defaultKernelName);
                const defaultKernel = new Kernel({
                    kernelManager,
                    kernelName: defaultKernelName,
                    kernelSpecName: defaultKernelName,
                    kernelType: 'notebook',
                    kernelspecsManager: serviceManager.kernelspecs,
                    sessionManager: serviceManager.sessions,
                });
                defaultKernel.ready.then(async () => {
                    if (initCode) {
                        try {
                            await defaultKernel.execute(initCode)?.done;
                        }
                        catch (error) {
                            console.error('Failed to execute the initial code', error);
                        }
                    }
                    console.log('Kernel is Ready', defaultKernel);
                    setKernel(defaultKernel);
                    setIsLoading(false);
                });
            }
        });
    }, [lite, serviceManager]);
    return (_jsx(ReduxProvider, { store: injectableStore, children: _jsx(JupyterProvider, { value: {
                // FIXME we should not expose sub attributes
                // to promote single source of truth (like URLs come from serverSettings)
                baseUrl: serviceManager?.serverSettings.baseUrl ?? '',
                collaborative,
                defaultKernel: kernel,
                defaultKernelIsLoading: kernelIsLoading,
                injectableStore,
                kernelManager: serviceManager?.kernels,
                lite: lite,
                serverSettings: serviceManager?.serverSettings ?? createServerSettings('', ''),
                serviceManager,
                setVariant,
                variant,
                wsUrl: serviceManager?.serverSettings.wsUrl ?? '',
            }, children: kernelIsLoading ? skeleton : children }) }));
};
//# sourceMappingURL=JupyterContext.js.map