/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { Widget } from '@lumino/widgets';
import { shims } from '@jupyter-widgets/base/lib/services-shim';
import { requireLoader } from '@jupyter-widgets/html-manager/lib/libembed-amd';
import { HTMLManager } from '@jupyter-widgets/html-manager/lib/htmlmanager';
import { valid } from 'semver';
import { SemVerCache } from '../semvercache';
import { WIDGET_STATE_MIMETYPE } from './../mimetypes';
import * as base from '@jupyter-widgets/base';
import * as controls from '@jupyter-widgets/controls';
/**
 * The class is responsible for the classic IPyWidget rendering.
 */
export class ClassicWidgetManager extends HTMLManager {
    _kernelConnection;
    _commRegistration;
    _onError;
    _registry;
    constructor(options) {
        super(options);
        window.define('@jupyter-widgets/base', base);
        window.define('@jupyter-widgets/controls', controls);
        this._registry = new SemVerCache();
        this.register = this.register.bind(this);
        this.registerWithKernel = this.registerWithKernel.bind(this);
        this._getRegistry = this._getRegistry.bind(this);
        this._handleCommOpen = this._handleCommOpen.bind(this);
        this.register({
            name: '@jupyter-widgets/base',
            version: base.JUPYTER_WIDGETS_VERSION,
            exports: () => import('@jupyter-widgets/base'),
        });
        this.register({
            name: '@jupyter-widgets/controls',
            version: controls.JUPYTER_CONTROLS_VERSION,
            exports: () => import('@jupyter-widgets/controls'),
        });
    }
    /**
     * Load widget state from notebook metadata
     */
    async _loadFromNotebook(notebook) {
        const widget_md = notebook.getMetadata('widgets');
        // Restore any widgets from saved state that are not live
        if (widget_md && widget_md[WIDGET_STATE_MIMETYPE]) {
            let state = widget_md[WIDGET_STATE_MIMETYPE];
            state = this.filterExistingModelState(state);
            await this.set_state(state);
        }
    }
    registerWithKernel(kernelConnection) {
        this._kernelConnection = kernelConnection;
        if (this._commRegistration) {
            this._commRegistration.dispose();
        }
        if (kernelConnection) {
            kernelConnection.registerCommTarget(this.comm_target_name, this._handleCommOpen);
        }
    }
    async _handleCommOpen(comm, message) {
        const classicComm = new shims.services.Comm(comm);
        await this.handle_comm_open(classicComm, message);
    }
    _getRegistry() {
        return this._registry;
    }
    get onError() {
        return this._onError;
    }
    display_view(view, el) {
        return Promise.resolve(view).then(view => {
            Widget.attach(view.luminoWidget, el);
            view.on('remove', () => {
                console.log('The IPyWidgets view is removed', view);
            });
            //      return view;
        });
    }
    /**
     * Load a class and return a promise to the loaded object.
     */
    async loadClass(className, moduleName, moduleVersion) {
        // Special-case the Jupyter base and controls packages. If we have just a
        // plain version, with no indication of the compatible range, prepend a ^ to
        // get all compatible versions. We may eventually apply this logic to all
        // widget modules. See issues #2006 and #2017 for more discussion.
        if ((moduleName === '@jupyter-widgets/base' ||
            moduleName === '@jupyter-widgets/controls') &&
            valid(moduleVersion)) {
            moduleVersion = `^${moduleVersion}`;
        }
        let allVersions = this._getRegistry().getAllVersions(moduleName);
        const semanticVersion = moduleVersion.split('.').length === 2
            ? moduleVersion + '.0'
            : moduleVersion;
        if (!allVersions) {
            const module = await requireLoader(moduleName, semanticVersion);
            const widgetRegistryData = {
                name: moduleName,
                version: semanticVersion.replaceAll('^', ''),
                exports: { ...module },
            };
            this.register(widgetRegistryData);
            allVersions = this._getRegistry().getAllVersions(moduleName);
            if (!allVersions) {
                throw new Error(`No version of module ${moduleName} is registered`);
            }
        }
        const mod = this._getRegistry().get(moduleName, semanticVersion);
        if (!mod) {
            const registeredVersionList = Object.keys(allVersions);
            throw new Error(`Module ${moduleName}, version ${semanticVersion} is not registered, however, \
        ${registeredVersionList.join(',')} ${registeredVersionList.length > 1 ? 'are' : 'is'}`);
        }
        let module;
        if (typeof mod === 'function') {
            module = await mod();
        }
        else {
            module = await mod;
        }
        const cls = module[className];
        if (!cls) {
            throw new Error(`Class ${className} not found in module ${moduleName}`);
        }
        return cls;
    }
    callbacks(view) {
        const baseCallbacks = super.callbacks(view);
        return Object.assign({}, baseCallbacks, {
            iopub: { output: (msg) => this._onError.emit(msg) },
        });
    }
    _create_comm(target_name, model_id, data, metadata, buffers) {
        const comm = this._kernelConnection?.createComm(target_name, model_id);
        if (data || metadata) {
            comm?.open(data, metadata);
        }
        return Promise.resolve(new shims.services.Comm(comm));
    }
    _get_comm_info() {
        return this._kernelConnection.requestCommInfo({
            target_name: this.comm_target_name,
        }).then((reply) => reply.content.comms);
    }
    loadBundledIPyWidgets = (ipywidgets) => {
        const loadIPyWidget = (name, version, module) => {
            requireLoader(name, version).then(module => {
                //
            });
        };
        ipywidgets.forEach(ipywidget => {
            loadIPyWidget(ipywidget.name, ipywidget.version, ipywidget.module);
        });
    };
    loadExternalIPyWidgets(ipywidgets) {
        const loadIPyWidget = (name, version) => {
            requireLoader(name, version).then(module => {
                //
            });
        };
        ipywidgets.forEach(ipywidget => {
            loadIPyWidget(ipywidget.name, ipywidget.version);
        });
    }
    register(data) {
        this._getRegistry().set(data.name, data.version, data.exports);
    }
}
export default ClassicWidgetManager;
//# sourceMappingURL=manager.js.map