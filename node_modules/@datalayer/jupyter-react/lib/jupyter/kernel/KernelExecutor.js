/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { PromiseDelegate } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
import { OutputAreaModel } from '@jupyterlab/outputarea';
import { outputsAsString } from '../../utils/Utils';
export class KernelExecutor {
    _kernelConnection;
    _outputs;
    _outputsChanged = new Signal(this);
    _model;
    _modelChanged = new Signal(this);
    _future;
    _shellMessageHooks = new Array();
    _executed;
    constructor({ connection, model }) {
        this._kernelConnection = connection;
        this._outputs = [];
        this._model = model ?? new OutputAreaModel();
        this._executed = new PromiseDelegate();
    }
    /**
     * Execute a code snippet.
     *
     * @param code Code to be executed
     * @param options Callbacks on IOPub messages and on reply message
     * @returns The outputs model
     *
     * @example
     * Here is an example to execute the code snippet `print('hello')`.
     *
     * ```ts
     * const executor = new KernelExecutor(kernelConnection);
     * const outputs = await executor.execute("print('hello')");
     * ```
     */
    execute(code, { iopubMessageHooks = [], shellMessageHooks = [], silent = false, stopOnError = false, storeHistory = true, } = {}) {
        this._shellMessageHooks = shellMessageHooks;
        this._future = this._kernelConnection.requestExecute({
            code,
            allow_stdin: false,
            silent,
            stop_on_error: stopOnError,
            store_history: storeHistory,
        });
        iopubMessageHooks.forEach(hook => this._future.registerMessageHook(hook));
        this._future.onIOPub = this._onIOPub;
        this._future.onReply = this._onReply;
        /*
        FIXME Handle stdin. It will require updating the `allow_stdin` param aboove  .
        future.onStdin = msg => {
          if (KernelMessage.isInputRequestMsg(msg)) {
            this.onInputRequest(msg, value);
          }
        };
        */
        // Wait for future to be done before resolving.
        this._future.done.then(() => {
            this._executed.resolve(this._model);
        });
        return this._executed.promise;
    }
    /**
     * Clear the kernel executor previous results.
     */
    clear() {
        this._shellMessageHooks.length = 0;
        this._outputs.length = 0;
        this._model.clear();
    }
    _onIOPub = (message) => {
        if (this._future?.msg.header.msg_id !== message.parent_header.msg_id) {
            return;
        }
        const messageType = message.header.msg_type;
        const output = { ...message.content, output_type: messageType };
        switch (messageType) {
            case 'execute_result':
                this._outputs.push(message.content);
                this._outputsChanged.emit(this._outputs);
                this._model.add(output);
                this._modelChanged.emit(this._model);
                break;
            case 'display_data':
                this._outputs.push(message.content);
                this._outputsChanged.emit(this._outputs);
                this._model.add(output);
                this._modelChanged.emit(this._model);
                break;
            case 'stream':
            case 'error':
                this._outputs.push(message.content);
                this._outputsChanged.emit(this._outputs);
                this._model.add(output);
                this._modelChanged.emit(this._model);
                break;
            case 'clear_output':
                const wait = message.content.wait;
                this._model.clear(wait);
                break;
            case 'update_display_data':
                this._outputs.push(message.content);
                this._outputsChanged.emit(this._outputs);
                // FIXME this needs more advanced analysis see OutputArea
                this._model.add(output);
                this._modelChanged.emit(this._model);
                break;
            case 'status':
                // execution_state: 'busy' 'starting' 'terminating' 'restarting' 'initializing' 'connecting' 'disconnected' 'dead' 'unknown' 'idle'
                const executionState = message.content.execution_state;
                executionState;
                break;
            default:
                break;
        }
    };
    _onReply = (message) => {
        if (this._future?.msg.header.msg_id !== message.parent_header.msg_id) {
            return;
        }
        this._shellMessageHooks.forEach(hook => hook(message));
        const content = message.content;
        if (content.status !== 'ok') {
            switch (content.status) {
                case 'abort':
                    this._executed.reject('Execution aborted.');
                    break;
                case 'error':
                    {
                        const { ename, evalue, traceback } = content.content;
                        this._executed.reject(`${ename}: ${evalue}\n${(traceback ?? []).join('\n')}`);
                    }
                    break;
            }
            return;
        }
        // API responses that contain a pager are special cased and their type
        // is overridden from 'execute_reply' to 'display_data' in order to
        // render output.
        const payload = content?.payload;
        if (payload?.length) {
            const pages = payload.filter((i) => i.source === 'page');
            if (pages.length) {
                const page = JSON.parse(JSON.stringify(pages[0]));
                const output = {
                    output_type: 'display_data',
                    data: page.data,
                    metadata: {},
                };
                this._outputs.push(output);
                this._outputsChanged.emit(this._outputs);
                this._model.add(output);
                this._modelChanged.emit(this._model);
            }
        }
    };
    registerIOPubMessageHook = (msg) => {
        this._future?.registerMessageHook(msg);
    };
    /**
     * Promise that resolves when the execution is done.
     */
    get done() {
        return this._executed.promise.then(() => {
            return;
        });
    }
    /**
     * Code execution result as serialized JSON
     */
    get result() {
        return this._executed.promise.then(model => {
            return outputsAsString(model.toJSON());
        });
    }
    /**
     * Kernel outputs emitted.
     */
    get outputs() {
        return this._outputs;
    }
    /**
     * Kernel outputs wrapped in a model.
     */
    get model() {
        return this._model;
    }
    /**
     * Signal emitted when the outputs list changes.
     */
    get outputsChanged() {
        0;
        return this._outputsChanged;
    }
    /**
     * Signal emitted when the outputs model changes.
     */
    get modelChanged() {
        return this._modelChanged;
    }
}
export default KernelExecutor;
//# sourceMappingURL=KernelExecutor.js.map