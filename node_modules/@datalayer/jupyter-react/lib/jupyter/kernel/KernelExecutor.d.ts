import { ISignal } from '@lumino/signaling';
import { IOutput } from '@jupyterlab/nbformat';
import { IOutputAreaModel } from '@jupyterlab/outputarea';
import { Kernel, KernelMessage } from '@jupyterlab/services';
export type IOPubMessageHook = (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>;
export type ShellMessageHook = (msg: KernelMessage.IShellMessage) => boolean | PromiseLike<boolean>;
/**
 * KernelExecutor options
 */
export interface IKernelExecutorOptions {
    /**
     * Kernel connection
     */
    connection: Kernel.IKernelConnection;
    /**
     * Outputs model to populate with the execution results.
     */
    model?: IOutputAreaModel;
}
export declare class KernelExecutor {
    private _kernelConnection;
    private _outputs;
    private _outputsChanged;
    private _model;
    private _modelChanged;
    private _future?;
    private _shellMessageHooks;
    private _executed;
    constructor({ connection, model }: IKernelExecutorOptions);
    /**
     * Execute a code snippet.
     *
     * @param code Code to be executed
     * @param options Callbacks on IOPub messages and on reply message
     * @returns The outputs model
     *
     * @example
     * Here is an example to execute the code snippet `print('hello')`.
     *
     * ```ts
     * const executor = new KernelExecutor(kernelConnection);
     * const outputs = await executor.execute("print('hello')");
     * ```
     */
    execute(code: string, { iopubMessageHooks, shellMessageHooks, silent, stopOnError, storeHistory, }?: {
        iopubMessageHooks?: IOPubMessageHook[];
        shellMessageHooks?: ShellMessageHook[];
        silent?: boolean;
        stopOnError?: boolean;
        storeHistory?: boolean;
    }): Promise<IOutputAreaModel>;
    /**
     * Clear the kernel executor previous results.
     */
    clear(): void;
    private _onIOPub;
    private _onReply;
    registerIOPubMessageHook: (msg: IOPubMessageHook) => void;
    /**
     * Promise that resolves when the execution is done.
     */
    get done(): Promise<void>;
    /**
     * Code execution result as serialized JSON
     */
    get result(): Promise<string>;
    /**
     * Kernel outputs emitted.
     */
    get outputs(): IOutput[];
    /**
     * Kernel outputs wrapped in a model.
     */
    get model(): IOutputAreaModel;
    /**
     * Signal emitted when the outputs list changes.
     */
    get outputsChanged(): ISignal<KernelExecutor, IOutput[]>;
    /**
     * Signal emitted when the outputs model changes.
     */
    get modelChanged(): ISignal<KernelExecutor, IOutputAreaModel>;
}
export default KernelExecutor;
