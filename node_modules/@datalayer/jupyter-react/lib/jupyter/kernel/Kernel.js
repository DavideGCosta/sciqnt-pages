/*
 * Copyright (c) 2021-2023 Datalayer, Inc.
 *
 * MIT License
 */
import { find } from '@lumino/algorithm';
import { PromiseDelegate, UUID } from '@lumino/coreutils';
import { getCookie } from '../../utils/Utils';
import KernelExecutor from './KernelExecutor';
const JUPYTER_REACT_PATH_COOKIE_NAME = 'jupyter-react-kernel-path';
/**
 * Jupyter Kernel handler
 */
export class Kernel {
    _clientId;
    _connectionStatus;
    _id;
    _info;
    _kernelConnection;
    _kernelManager;
    _kernelName;
    _kernelSpecManager;
    _kernelSpecName;
    _kernelType;
    _path;
    _ready;
    _session;
    _sessionId;
    _sessionManager;
    constructor(props) {
        const { kernelManager, kernelName, kernelType, kernelspecsManager, kernelSpecName, kernelModel, sessionManager, } = props;
        this._kernelSpecManager = kernelspecsManager;
        this._kernelManager = kernelManager;
        this._kernelName = kernelName;
        this._kernelType = kernelType;
        this._kernelSpecName = kernelSpecName;
        this._sessionManager = sessionManager;
        this._ready = new PromiseDelegate();
        this.requestKernel(kernelModel);
    }
    async requestKernel(kernelModel) {
        await this._kernelManager.ready;
        await this._sessionManager.ready;
        if (kernelModel) {
            console.log('Reusing a pre-existing kernel model.');
            await this._sessionManager.refreshRunning();
            const model = find(this._sessionManager.running(), item => {
                return item.path === this._path;
            });
            if (model) {
                this._session = this._sessionManager.connectTo({ model });
            }
        }
        else {
            let path = getCookie(this.cookieName);
            if (!path) {
                path = 'kernel-' + UUID.uuid4();
                document.cookie = this.cookieName + '=' + path;
            }
            this._path = path;
            this._session = await this._sessionManager.startNew({
                name: this._kernelName,
                path: this._path,
                type: this._kernelType,
                kernel: {
                    name: this._kernelSpecName,
                },
            }, {
                kernelConnectionOptions: {
                    handleComms: true,
                },
            });
        }
        this._kernelConnection = this._session.kernel;
        const updateConnectionStatus = () => {
            if (this._connectionStatus === 'connected') {
                this._clientId = this._session.kernel.clientId;
                this._id = this._session.kernel.id;
                this._ready.resolve();
            }
        };
        if (this._kernelConnection) {
            this._sessionId = this._session.id;
            this._connectionStatus = this._kernelConnection.connectionStatus;
            updateConnectionStatus();
            this._kernelConnection.connectionStatusChanged.connect((_, connectionStatus) => {
                //        this.initReady();
                this._connectionStatus = connectionStatus;
                updateConnectionStatus();
            });
            this._kernelConnection.info.then(info => {
                this._info = info;
                console.log('Kernel Info', this.toJSON());
            });
        }
    }
    get clientId() {
        return this._clientId;
    }
    get connection() {
        return this._kernelConnection;
    }
    get cookieName() {
        return JUPYTER_REACT_PATH_COOKIE_NAME + '_' + this._kernelSpecName;
    }
    get id() {
        return this._id;
    }
    get info() {
        return this._info;
    }
    get kernelManager() {
        return this._kernelManager;
    }
    get kernelSpecManager() {
        return this._kernelSpecManager;
    }
    get path() {
        return this._path;
    }
    get ready() {
        return this._ready.promise;
    }
    get sessionId() {
        return this._sessionId;
    }
    get session() {
        return this._session;
    }
    get sessionManager() {
        return this._sessionManager;
    }
    /**
     * Execute a code snippet
     *
     * @param code The code snippet
     * @param options Callbacks on IOPub messages and on reply message,
     *  outputs model to populate and execution options
     * @returns The kernel executor
     */
    execute(code, { iopubMessageHooks = [], shellMessageHooks = [], model, silent, stopOnError, storeHistory, } = {}) {
        if (this._kernelConnection) {
            const kernelExecutor = new KernelExecutor({
                connection: this._kernelConnection,
                model,
            });
            kernelExecutor.execute(code, {
                iopubMessageHooks,
                shellMessageHooks,
                silent,
                stopOnError,
                storeHistory,
            });
            return kernelExecutor;
        }
    }
    /**
     * Interrupt the kernel
     */
    interrupt() {
        return this._kernelConnection?.interrupt() ?? Promise.resolve();
    }
    /**
     * Restart the kernel
     */
    restart() {
        return this._kernelConnection?.restart() ?? Promise.resolve();
    }
    /**
     * Shutdown the kernel
     */
    async shutdown() {
        await this._session.kernel?.shutdown();
        this.connection?.dispose();
    }
    /**
     * Serialize the kernel to JSON
     */
    toJSON() {
        return {
            path: this._path,
            id: this.id,
            clientId: this.clientId,
            sessionId: this.sessionId,
            kernelInfo: this.info,
        };
    }
    /**
     * Serialize the kernel to string
     */
    toString() {
        return `id:${this.id} - client_id:${this.clientId} - session_id:${this.sessionId} - path:${this._path}`;
    }
}
export default Kernel;
//# sourceMappingURL=Kernel.js.map