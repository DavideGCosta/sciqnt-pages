/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
import { Signal } from '@lumino/signaling';
import * as decoding from 'lib0/decoding';
import * as encoding from 'lib0/encoding';
import { WebsocketProvider } from 'y-websocket';
export var MessageType;
(function (MessageType) {
    MessageType[MessageType["CHAT"] = 125] = "CHAT";
})(MessageType || (MessageType = {}));
/**
 * A class to provide Yjs synchronization over WebSocket.
 *
 * We specify custom messages that the server can interpret. For reference please look in yjs_ws_server.
 *
 */
export class WebSocketAwarenessProvider extends WebsocketProvider {
    /**
     * Construct a new WebSocketAwarenessProvider
     *
     * @param options The instantiation options for a WebSocketAwarenessProvider
     */
    constructor(options) {
        super(options.url, options.roomID, options.awareness.doc, {
            awareness: options.awareness
        });
        this._isDisposed = false;
        this._awareness = options.awareness;
        const user = options.user;
        user.ready
            .then(() => this._onUserChanged(user))
            .catch(e => console.error(e));
        user.userChanged.connect(this._onUserChanged, this);
        this._chatMessage = new Signal(this);
        this.messageHandlers[MessageType.CHAT] = (encoder, decoder, provider, emitSynced, messageType) => {
            const content = decoding.readVarString(decoder);
            const data = JSON.parse(content);
            console.debug('Chat:', data);
            this._chatMessage.emit(data);
        };
    }
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * A signal to subscribe for incoming messages.
     */
    get chatMessage() {
        return this._chatMessage;
    }
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this.destroy();
        this._isDisposed = true;
    }
    /**
     * Send a message to every collaborator.
     *
     * @param msg message
     */
    sendMessage(msg) {
        console.debug('Send message:', msg);
        const encoder = encoding.createEncoder();
        encoding.writeVarUint(encoder, MessageType.CHAT);
        encoding.writeVarString(encoder, msg);
        this.ws.send(encoding.toUint8Array(encoder));
    }
    _onUserChanged(user) {
        this._awareness.setLocalStateField('user', user.identity);
    }
}
